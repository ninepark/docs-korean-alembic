# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010-2019, Mike Bayer
# This file is distributed under the same license as the Alembic package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Alembic 1.0.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-04 13:27+0900\n"
"PO-Revision-Date: 2019-03-15 19:07+0900\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko\n"
"X-Generator: Poedit 2.2.1\n"

#: ../autogenerate.rst:2
msgid "Auto Generating Migrations"
msgstr "마이그레이션 자동 생성"

#: ../autogenerate.rst:4
msgid ""
"Alembic can view the status of the database and compare against the "
"table metadata in the application, generating the \"obvious\" migrations "
"based on a comparison.  This is achieved using the ``--autogenerate`` "
"option to the ``alembic revision`` command, which places so-called "
"*candidate* migrations into our new migrations file.  We review and "
"modify these by hand as needed, then proceed normally."
msgstr ""
"Alembic은 데이터베이스의 상태를 볼 수 있고 어플리케이션 안의 테이블 메타"
"데이터에 대해 비교할 수 있으므로, 비교에 기반한 “확실한” 마이그레이션을 "
"한다.  ``alembic revision`` 명령의 ``—autogenerate`` 옵션을 사용하면, 소"
"위 *후보* 마이그레이션을 새로운 마이그레이션 파일에 배치한다.  필요에 따"
"라 수동으로 재검토하고 수정한 다음, 일반적 방식으로 계속해서 진행한다."

#: ../autogenerate.rst:10
msgid ""
"To use autogenerate, we first need to modify our ``env.py`` so that it "
"gets access to a table metadata object that contains the target.  "
"Suppose our application has a :ref:`declarative base <sqla:"
"declarative_toplevel>` in ``myapp.mymodel``.  This base contains a :"
"class:`~sqlalchemy.schema.MetaData` object which contains :class:"
"`~sqlalchemy.schema.Table` objects defining our database.  We make sure "
"this is loaded in ``env.py`` and then passed to :meth:`."
"EnvironmentContext.configure` via the ``target_metadata`` argument.   "
"The ``env.py`` sample script used in the generic template already has a "
"variable declaration near the top for our convenience, where we replace "
"``None`` with our :class:`~sqlalchemy.schema.MetaData`.  Starting with::"
msgstr ""
"자동생성을 사용하기 위해, 우선 ``env.py``\\을 수정하여 타겟을 포함하고 있"
"는 테이블 메타데이터 객체에 접근하도록 한다. 우리의 어플리케이션이 "
"``myapp.mymodel`` 안에 :ref:`declarative base <sqla:"
"declarative_toplevel>`\\을 가진다고 가정해보자.  이 base는 데이터베이스"
"를 정의하는 :class:`~sqlalchemy.schema.Table` 객체를 담고 있는 :class:"
"`~sqlalchemy.schema.MetaData` 객체를 포함한다.  이것이 ``env.py`` 안에 로"
"드되고, 그 다음에 ``target_metadata`` 인자를 통해 :meth:`."
"EnvironmentContext.configure`\\로 전달되었는지 확인한다.  일반 템플릿에"
"서 사용되는 ``env.py`` 샘플 스크립트는 편의상 상단에서 변수 선언을 하며, "
"``None``\\을 :class:`~sqlalchemy.schema.MetaData`\\로 대체한다.  다음과 "
"같이 시작한다::"

#: ../autogenerate.rst:27
msgid "we change to::"
msgstr "이렇게 변경한다::"

#: ../autogenerate.rst:34
msgid ""
"The above example refers to the **generic alembic env.py template**, e."
"g. the one created by default when calling upon ``alembic init``, and "
"not the special-use templates such as ``multidb``.   Please consult the "
"source code and comments within the ``env.py`` script directly for "
"specific guidance on where and how the autogenerate metadata is "
"established."
msgstr ""
"위의 예시는 ``alembic init``\\을 통해 호출되었을 때 기본적으로 생성되는 "
"것과 같은 **일반적 alembic env.py 템플릿**을 나타내며, ``multidb``\\와 같"
"이 특별한 용도의 템플릿이 아니다.  자동생성 메타데이터가 어디에 그리고 어"
"떻게 만들어지는지에 대한 구체적인 안내는 직접 ``env.py`` 스크립트 안에 있"
"는 소스 코드와 코멘트를 참고하라."

#: ../autogenerate.rst:40
msgid ""
"If we look later in the script, down in ``run_migrations_online()``, we "
"can see the directive passed to :meth:`.EnvironmentContext.configure`::"
msgstr ""
"다시 스크립트를 보면, ``run_migrations_online()``\\에서 :meth:`."
"EnvironmentContext.configure`\\로 지시문이 전달된 것을 볼 수 있다::"

#: ../autogenerate.rst:56
msgid ""
"We can then use the ``alembic revision`` command in conjunction with the "
"``--autogenerate`` option.  Suppose our :class:`~sqlalchemy.schema."
"MetaData` contained a definition for the ``account`` table, and the "
"database did not.  We'd get output like::"
msgstr ""
"그 다음 ``—autogenerate`` 옵션과 함께 ``alembic revision`` 명령어를 사용"
"할 수 있다.  :class:`~sqlalchemy.schema.MetaData`\\가 ``account`` 테이블"
"에 대한 정의를 포함하고 있고, 데이터베이스에는 없다고 가정하자.  다음과 "
"같은 결과를 얻을 것이다::"

#: ../autogenerate.rst:65
msgid ""
"We can then view our file ``27c6a30d7c24.py`` and see that a rudimentary "
"migration is already present::"
msgstr ""
"그 다음 ``27c6a30d7c24.py`` 파일을 보면 기본 마이그레이션이 이미 있는 것"
"을 확인할 수 있다::"

#: ../autogenerate.rst:100
msgid ""
"The migration hasn't actually run yet, of course.  We do that via the "
"usual ``upgrade`` command.   We should also go into our migration file "
"and alter it as needed, including adjustments to the directives as well "
"as the addition of other directives which these may be dependent on - "
"specifically data changes in between creates/alters/drops."
msgstr ""
"당연히, 마이그레이션은 실제로 아직 실행되기 전이다.  보통 ``upgrade`` 명"
"령어를 통해서 한다.  마이그레이션 파일로 가서 필요에 따라 지시문을 조정"
"할 뿐 아니라 생성/수정/삭제 사이의 명확한 데이터 변경에 종속된 다른 지시"
"문을 추가할 수 있다."

#: ../autogenerate.rst:106
msgid "What does Autogenerate Detect (and what does it *not* detect?)"
msgstr "자동생성에서 어떤 것이 감지하는가 (그리고 감지되지 *못* 하는가?)"

#: ../autogenerate.rst:108
msgid ""
"The vast majority of user issues with Alembic centers on the topic of "
"what kinds of changes autogenerate can and cannot detect reliably, as "
"well as how it renders Python code for what it does detect.     it is "
"critical to note that **autogenerate is not intended to be perfect**.   "
"It is *always* necessary to manually review and correct the **candidate "
"migrations** that autogenererate produces.   The feature is getting more "
"and more comprehensive and error-free as releases continue, but one "
"should take note of the current limitations."
msgstr ""
"엄청나게 많은 Alembic 사용자 이슈의 대다수 것들은 어떤 종류의 변경 사항"
"을 자동생성으로 확실하게 감지할 수 있고, 또는 감지할 수 없는지에 대한 주"
"제와, 감지하는 파이썬 코드를 어떻게 렌더링하는지에 대한 것이다.    **자동"
"생성은 완벽하게 만들어지지 않았다**는 점을 알아두는 것이 매우 중요하다.  "
"자동생성으로 만들어진 **후보 마이그레이션**을 *항상* 직접 검토하고 수정하"
"는 것이 중요하다.  이 기능은 계속 릴리즈 되면서 점점 더 종합적이 되고 에"
"러가 없어지겠지만, 현재 상태에서의 한계를 항상 인지하고 있어야 한다."

#: ../autogenerate.rst:117
msgid "Autogenerate **will detect**:"
msgstr "자동생성으로 **감지**할 수 있는 것::"

#: ../autogenerate.rst:119
msgid "Table additions, removals."
msgstr "테이블 추가, 삭제."

#: ../autogenerate.rst:120
msgid "Column additions, removals."
msgstr "컬럼 추가, 삭제."

#: ../autogenerate.rst:121
msgid "Change of nullable status on columns."
msgstr "컬럼의 null 허용 상태 변경."

#: ../autogenerate.rst:122
msgid "Basic changes in indexes and explcitly-named unique constraints"
msgstr "인덱스 및 명시적인 이름이 있는 고유 제약 사항의 기본적인 변경"

#: ../autogenerate.rst:124
msgid "Support for autogenerate of indexes and unique constraints."
msgstr "인덱스와 고유 제약 사항의 자동생성이 지원됨."

#: ../autogenerate.rst:126
msgid "Basic changes in foreign key constraints"
msgstr "외부 키 제약에 대한 기본적인 변경"

#: ../autogenerate.rst:128
msgid "Support for autogenerate of foreign key constraints."
msgstr "외부 키 제약 사항의 자동생성이 지원됨."

#: ../autogenerate.rst:130
msgid "Autogenerate can **optionally detect**:"
msgstr "자동생성으로 *선택적으로 감지*될 수 있는 것:"

#: ../autogenerate.rst:132
msgid ""
"Change of column type.  This will occur if you set the :paramref:`."
"EnvironmentContext.configure.compare_type` parameter to ``True``, or to "
"a custom callable function. The feature works well in most cases, but is "
"off by default so that it can be tested on the target schema first.  It "
"can also be customized by passing a callable here; see the section :ref:"
"`compare_types` for details."
msgstr ""
"컬럼 타입의 변경. 만약 :paramref:`.EnvironmentContext.configure."
"compare_type` 매개변수를 ``True`` 또는 사용자 맞춤형의 호출 가능한 함수"
"로 설정했다면, 컬럼 타입 변경을 감지할 것이다. 이 기능은 대부분의 경우에"
"서 잘 작동하지만, 기본값으로는 작동 안하기 때문에 먼저 타겟 스키마에 대"
"해 테스트해 볼 수 있다.  또한, 여기에 호출 가능한 것을 전달하여 사용에 맞"
"게 변경할 수 있다; 자세한 것은 :ref:`compare_types` 부분을 보라."

#: ../autogenerate.rst:139
msgid ""
"Change of server default.  This will occur if you set the :paramref:`."
"EnvironmentContext.configure.compare_server_default` parameter to "
"``True``, or to a custom callable function. This feature works well for "
"simple cases but cannot always produce accurate results.  The Postgresql "
"backend will actually invoke the \"detected\" and \"metadata\" values "
"against the database to determine equivalence.  The feature is off by "
"default so that it can be tested on the target schema first.  Like type "
"comparison, it can also be customized by passing a callable; see the "
"function's documentation for details."
msgstr ""
"서버 기본값의 변경.  만약 :paramref:`.EnvironmentContext.configure."
"compare_server_default` 매개변수를 ``True`` 또는 사용자 맞춤형의 호출 가"
"능한 함수로 설정했다면, 변경을 감지할 것이다. 이 기능은 간단한 케이스에서"
"는 잘 작동하지만 항상 정확한 결과를 제공하지는 못한다.  실제로 "
"Postgresql 백엔드는 데이터베이스에 대한 “감지”와 “메타데이터” 값을 동작시"
"켜 동등성을 판별한다.  이 기능은 작동 안하는 것이 기본값이기 때문에 타겟 "
"스키마에 먼저 테스트를 먼저 해볼 수 있다.  타입 비교와 마찬가지로, 여기"
"에 호출 가능한 것을 전달하여 사용에 맞게 변경할 수 있다; 자세한 것은 이 "
"기능의 문서를 보라."

#: ../autogenerate.rst:150
msgid "Autogenerate **can not detect**:"
msgstr "자동생성으로 *감지할 수 없는 것*:"

#: ../autogenerate.rst:152
msgid ""
"Changes of table name.   These will come out as an add/drop of two "
"different tables, and should be hand-edited into a name change instead."
msgstr ""
"테이블 이름의 변경.  두 개의 다른 테이블의 추가/삭제하는 것으로 나올 것이"
"며, 이름의 변경은 수동으로 해주어야 한다."

#: ../autogenerate.rst:154
msgid ""
"Changes of column name.  Like table name changes, these are detected as "
"a column add/drop pair, which is not at all the same as a name change."
msgstr ""
"컬럼 이름의 변경.  테이블 이름의 변경처럼, 이름 변경과 전혀 동일하지 않"
"은, 두 개의 컬럼의 추가/삭제로 감지된다."

#: ../autogenerate.rst:156
msgid ""
"Anonymously named constraints.  Give your constraints a name, e.g. "
"``UniqueConstraint('col1', 'col2', name=\"my_name\")``.  See the "
"section :doc:`naming` for background on how to configure automatic "
"naming schemes for constraints."
msgstr ""
"익명으로 이름 붙여진 제약사항.  예를 들어 ``UniqueConstraint(‘col1’, "
"‘col2’, name=“my_name”)``\\처럼 제약사항에 이름을 붙인다.  제약사항에 자"
"동으로 명명하는 스키마 설정 방법에 대한 배경은 :doc:`naming` 부분을 보라."

#: ../autogenerate.rst:160
msgid ""
"Special SQLAlchemy types such as :class:`~sqlalchemy.types.Enum` when "
"generated on a backend which doesn't support ENUM directly - this "
"because the representation of such a type in the non-supporting "
"database, i.e. a CHAR+ CHECK constraint, could be any kind of CHAR"
"+CHECK.  For SQLAlchemy to determine that this is actually an ENUM would "
"only be a guess, something that's generally a bad idea. To implement "
"your own \"guessing\" function here, use the :meth:`sqlalchemy.events."
"DDLEvents.column_reflect` event to detect when a CHAR (or whatever the "
"target type is) is reflected, and change it to an ENUM (or whatever type "
"is desired) if it is known that that's the intent of the type.  The :"
"meth:`sqlalchemy.events.DDLEvents.after_parent_attach` can be used "
"within the autogenerate process to intercept and un-attach unwanted "
"CHECK constraints."
msgstr ""
":class:`~sqlalchemy.types.Enum`\\와 같이 특별한 SQLAlchemy 타입이 ENUM을 "
"직접적으로 지원하지 않는 백엔드에서 만들어졌을 때 - 왜냐하면 비지원 데이"
"터베이스에서 이러한 타입의 표현, 즉 CHAR+ CHECK 제약 사항은 아무 종류의 "
"CHAR + CHECK가 될 수 있기 때문이다.  SQLAlchemy가 이것이 실제 ENUM인지 추"
"측하여 판별하도록 하는 것은 일반적으로 좋지 않다. 여기에 “추측” 함수를 구"
"현하려면, :meth:`sqlalchemy.events.DDLEvents.column_reflect` 이벤트를 사"
"용해 CHAR(또는 다른 대상 타입)가 반영됐을 때를 감지하고, 해당 타입의 의도"
"를 알고 있는 경우 ENUM(또는 원하는 타입)으로 변경한다.  :meth:"
"`sqlalchemy.events.DDLEvents.after_parent_attach`\\는 자동생성 프로세스 "
"안에서 원하지 않는 CHECK 제약 사항을 가로막고 제거하기 위해서 사용할 수 "
"있다."

#: ../autogenerate.rst:175
msgid "Autogenerate can't currently, but **will eventually detect**:"
msgstr "현재는 자동 생성으로 감지 못하지만, **결국에는 감지해 낼 것** :"

#: ../autogenerate.rst:177
msgid ""
"Some free-standing constraint additions and removals may not be "
"supported, including PRIMARY KEY, EXCLUDE, CHECK; these are not "
"necessarily implemented within the autogenerate detection system and "
"also may not be supported by the supporting SQLAlchemy dialect."
msgstr ""
"PRIMARY KEY, EXCLUDE, CHECK를 포함하는, 일부 독립된 제약 사항의 추가와 삭"
"제는 지원되지 않을 수 있다; 이것들은 필수로 자동생성 감지 시스템 내에 구"
"현되지 않고, SQLAlchemy 용어에 의해서도 지원되지 않을 수 있다."

#: ../autogenerate.rst:181
msgid "Sequence additions, removals - not yet implemented."
msgstr "시퀀스의 추가, 삭제 - 아직까지 구현되지 않음."

#: ../autogenerate.rst:184
msgid "Autogenerating Multiple MetaData collections"
msgstr "여러 메타데이터 콜렉션 자동생성"

#: ../autogenerate.rst:186
msgid ""
"The ``target_metadata`` collection may also be defined as a sequence if "
"an application has multiple :class:`~sqlalchemy.schema.MetaData` "
"collections involved::"
msgstr ""
"어플리케이션이 여러 :class:`~sqlalchemy.schema.MetaData` 콜렉션을 가지고 "
"있다면 ``target_metadata`` 콜렉션은 시퀀스로 정의될 수 있다::"

#: ../autogenerate.rst:194
msgid ""
"The sequence of :class:`~sqlalchemy.schema.MetaData` collections will be "
"consulted in order during the autogenerate process.  Note that each :"
"class:`~sqlalchemy.schema.MetaData` must contain **unique** table keys "
"(e.g. the \"key\" is the combination of the table's name and schema); if "
"two :class:`~sqlalchemy.schema.MetaData` objects contain a table with "
"the same schema/name combination, an error is raised."
msgstr ""
":class:`~sqlalchemy.schema.MetaData` 콜렉션의 시퀀스는 자동생성 프로세스 "
"중에 순서대로 참조된다.  각각의 :class:`~sqlalchemy.schema.MetaData`\\는 "
"반드시 **고유한** 테이블 키(예를 들어 “키”는 테이블의 이름과 스키마의 조"
"합이다)를 포함해야 함을 인지하라; 만약 두 개의 :class:`~sqlalchemy."
"schema.MetaData` 객체가 동일한 스키마/이름 조합의 테이블을 담고 있다면, "
"에러가 발생한다."

#: ../autogenerate.rst:201
msgid ""
"the :paramref:`.EnvironmentContext.configure.target_metadata` parameter "
"may now be passed a sequence of :class:`~sqlalchemy.schema.MetaData` "
"objects to support autogeneration of multiple :class:`~sqlalchemy.schema."
"MetaData` collections."
msgstr ""
"이제 :paramref:`.EnvironmentContext.configure.target_metadata` 매개변수"
"에 :class:`~sqlalchemy.schema.MetaData` 객체의 시퀀스가 전달되어 여러 :"
"class:`~sqlalchemy.schema.MetaData` 콜렉션의 자동 생성을 지원할 수 있다."

#: ../autogenerate.rst:209
msgid "Comparing and Rendering Types"
msgstr "비교 및 렌더링 타입"

#: ../autogenerate.rst:211
msgid ""
"The area of autogenerate's behavior of comparing and rendering Python-"
"based type objects in migration scripts presents a challenge, in that "
"there's a very wide variety of types to be rendered in scripts, "
"including those part of SQLAlchemy as well as user-defined types.   A "
"few options are given to help out with this task."
msgstr ""
"SQLAlchemy 부분과 및 사용자 정의 타입을 포함하여, 스크립트로 렌더링 될 매"
"우 다양한 타입이 있다는 점에서 마이그레이션 스크립트에서 파이썬 기반의 타"
"입 객체를 비교하고 렌더링하는 자동생성 동작의 영역은 많은 어려움을 가지"
"고 있다.  몇 가지 옵션이 이러한 작업을 돕기 위하여 제공된다."

#: ../autogenerate.rst:220
msgid "Controlling the Module Prefix"
msgstr "모듈 접두사 제어"

#: ../autogenerate.rst:222
msgid ""
"When types are rendered, they are generated with a **module prefix**, so "
"that they are available based on a relatively small number of imports. "
"The rules for what the prefix is is based on the kind of datatype as "
"well as configurational settings.   For example, when Alembic renders "
"SQLAlchemy types, it will by default prefix the type name with the "
"prefix ``sa.``::"
msgstr ""
"타입이 렌더링될 때, **모듈 접두사**를 이용해 생성되기 때문에, 비교적 적"
"은 수의 임포트를 기반으로 가능하다. 접두어가 무엇인지에 대한 규칙은 테이"
"터타입의 종류 뿐만 아니라 구성 설정을 바탕으로 한다.  예를 들어, Alembic"
"이 SQLAlcehmy 타입을 렌더링할 때, 기본적으로 ``sa.``\\를 가지고 타입 이"
"름 앞에 접두사를 붙인다::"

#: ../autogenerate.rst:230
msgid ""
"The use of the ``sa.`` prefix is controllable by altering the value of :"
"paramref:`.EnvironmentContext.configure.sqlalchemy_module_prefix`::"
msgstr ""
"``sa.`` 접두사의 사용은 :paramref:`.EnvironmentContext.configure."
"sqlalchemy_module_prefix`의 값을 변경하는 것으로 제어가능하다::"

#: ../autogenerate.rst:245
msgid ""
"In either case, the ``sa.`` prefix, or whatever prefix is desired, "
"should also be included in the imports section of ``script.py.mako``; it "
"also defaults to ``import sqlalchemy as sa``."
msgstr ""
"어느 경우라도, ``sa`` 접두사, 또는 원하는 접두사는 ``script.py.mako``"
"\\의 임포트 부분에 포함되어 있어야 한다; 또한 이것은 ``import sqlalchemy "
"as sa``\\을 기본값으로 한다."

#: ../autogenerate.rst:250
msgid ""
"For user-defined types, that is, any custom type that is not within the "
"``sqlalchemy.`` module namespace, by default Alembic will use the "
"**value of __module__ for the custom type**::"
msgstr ""
"사용자 정의 유형, 즉, ``sqlalchemy.``모듈 네임스페이스에 없는 어떠한 사용"
"자가 변경 가능한 유형은, Alembic이 기본값으로 **사용자 정의 유형의 "
"__module__의 값**을 사용할 것이다::"

#: ../autogenerate.rst:256
msgid ""
"The imports for the above type again must be made present within the "
"migration, either manually, or by adding it to ``script.py.mako``."
msgstr ""
"위와 같은 사용자 변경 가능한 타입을 위한 임포트는 수동으로든, ``script."
"py.mako`` 안에 추가해서든, 마이그레이션 내에 있어야 한다."

#: ../autogenerate.rst:259
msgid ""
"The default module prefix rendering for a user-defined type now makes "
"use of the type's ``__module__`` attribute to retrieve the prefix, "
"rather than using the value of :paramref:`~.EnvironmentContext.configure."
"sqlalchemy_module_prefix`."
msgstr ""
"이제 사용자 정의 타입을 위한 기본 모듈 접두사 렌더링은 :paramref:`~."
"EnvironmentContext.configure.sqlalchemy_module_prefix`\\의 값을 사용하는 "
"대신, 접두사를 검색하기 위한 유형의``__module__`` 속성의 사용한다."

#: ../autogenerate.rst:266
msgid ""
"The above custom type has a long and cumbersome name based on the use of "
"``__module__`` directly, which also implies that lots of imports would "
"be needed in order to accomodate lots of types.  For this reason, it is "
"recommended that user-defined types used in migration scripts be made "
"available from a single module.  Suppose we call it ``myapp."
"migration_types``::"
msgstr ""
"위의 사용자 정의 타입은 ``__module__~`\\을 직접적으로 사용하여 길고 무거"
"운 이름을 가지는데, 이는 많은 타입을 수용하기 위하여 수 많은 임포트가 필"
"요할 것임을 암시한다.  이러한 이유로, 마이그레이션 스크립트에서 사용되는 "
"사용자 정의 유형은 단일 모듈에서 사용할 것을 추천한다. 이를 ``myapp."
"migration_types``\\로 부른다고 가정하자::"

#: ../autogenerate.rst:276
msgid ""
"We can first add an import for ``migration_types`` to our ``script.py."
"mako``::"
msgstr ""
"우선 ``migration_types``\\에 대한 임포트를 ``script.py.mako``\\에 추가할 "
"수 있다::"

#: ../autogenerate.rst:283
msgid ""
"We then override Alembic's use of ``__module__`` by providing a fixed "
"prefix, using the :paramref:`.EnvironmentContext.configure."
"user_module_prefix` option::"
msgstr ""
"그 다음 :paramref:`.EnvironmentContext.configure.user_module_prefix` 옵션"
"을 사용하여, 고정된 접두사를 제공하는 것으로 Alembic의 ``__module__~`` 사"
"용을 오버라이드한다::"

#: ../autogenerate.rst:299
msgid "Above, we now would get a migration like::"
msgstr "위에서 처럼, 이제 다음과 같은 마이그레이션을 할 것이다::"

#: ../autogenerate.rst:303
msgid ""
"Now, when we inevitably refactor our application to move "
"``MyCustomType`` somewhere else, we only need modify the ``myapp."
"migration_types`` module, instead of searching and replacing all "
"instances within our migration scripts."
msgstr ""
"이제, 부득이 하게 ``MyCustomType``을 어딘가로 옮기기 위하여 어플리케이션"
"을 리팩터링 할 때, 마이그레이션 스크립트 내의 모든 인스턴스를 검색하고 바"
"꾸는 대신 ``myapp.migration_types`` 모듈만 수정하면 된다."

#: ../autogenerate.rst:307
msgid "Added :paramref:`.EnvironmentContext.configure.user_module_prefix`."
msgstr ""
":paramref:`.EnvironmentContext.configure.user_module_prefix`\\가 추가되었"
"다."

#: ../autogenerate.rst:312
msgid "Affecting the Rendering of Types Themselves"
msgstr "타입 렌더링 시 영향을 주는 것"

#: ../autogenerate.rst:314
msgid ""
"The methodology Alembic uses to generate SQLAlchemy and user-defined "
"type constructs as Python code is plain old ``__repr__()``.   "
"SQLAlchemy's built-in types for the most part have a ``__repr__()`` that "
"faithfully renders a Python-compatible constructor call, but there are "
"some exceptions, particularly in those cases when a constructor accepts "
"arguments that aren't compatible with ``__repr__()``, such as a pickling "
"function."
msgstr ""
"파이썬 코드로 SQLAlchemy와 사용자 정의 타입의 생성자를 만들기 위한 "
"Alembic의 방법은 일반적이고 오래된 ``__repr__()``\\이다.  대부분의 "
"SQLAlchemy에 내장된 타입은 ``__repr__()``\\을 가지고 있는데, 이것은 파이"
"썬으로 호환될 수 있는 생성자를 호출하여 정확하게 렌더링하지만, pickling "
"함수처럼 ``__repr__()``\\로 호환될 수 없는 인자를 받는 생성자의 경우에는 "
"예외적이다."

#: ../autogenerate.rst:321
msgid ""
"When building a custom type that will be rendered into a migration "
"script, it is often necessary to explicitly give the type a "
"``__repr__()`` that will faithfully reproduce the constructor for that "
"type.   This, in combination with :paramref:`.EnvironmentContext."
"configure.user_module_prefix`, is usually enough.  However, if "
"additional behaviors are needed, a more comprehensive hook is the :"
"paramref:`.EnvironmentContext.configure.render_item` option. This hook "
"allows one to provide a callable function within ``env.py`` that will "
"fully take over how a type is rendered, including its module prefix::"
msgstr ""
"마이그레이션 스크립트로 렌더링되는 맞춤형 타입을 빌드할 때, 생성자를 제대"
"로 만들 ``__repr__()``\\을 해당 타입에 명시적으로 주는 것이 자주 있다.  "
"이것은 보통 :paramref:`.EnvironmentContext.configure.user_module_prefix`"
"\\와 함께 결합해서 사용하면 충분하다.  하지만, 추가적인 동작이 필요하다"
"면, 보다 더 포괄적인 훅으로 :paramref:`.EnvironmentContext.configure."
"render_item 옵션이 있다. 이 훅은 ``env.py`` 안에서 모듈의 접두사를 포함하"
"여 타입이 어떻게 렌더링되어야 하는지에 대한 모든 것을 맡아줄 호출 가능한 "
"함수를 제공한다::"

#: ../autogenerate.rst:351
#, python-format
msgid ""
"In the above example, we'd ensure our ``MySpecialType`` includes an "
"appropriate ``__repr__()`` method, which is invoked when we call it "
"against ``\"%r\"``."
msgstr ""
"위의 예시에서는, ``MySpecialType`` 안에 ``”%r”``\\에 대해 호출할 때 실행"
"되는 적절한 ``__repr__()`` 메소드를 포함하게 한다."

#: ../autogenerate.rst:354
msgid ""
"The callable we use for :paramref:`.EnvironmentContext.configure."
"render_item` can also add imports to our migration script.  The :class:`."
"AutogenContext` passed in contains a datamember called :attr:`."
"AutogenContext.imports`, which is a Python ``set()`` for which we can "
"add new imports.  For example, if ``MySpecialType`` were in a module "
"called ``mymodel.types``, we can add the import for it as we encounter "
"the type::"
msgstr ""
"또한 :paramref:`.EnvironmentContext.configure.render_item`\\을 위해 사용"
"한 호출 가능한 함수로 마이그레이션 스크립트에 임포트를 추가할 수 있다. 전"
"달된 :class:`.AutogenContext`\\는 :attr:`.AutogenContext.imports`\\로 호"
"출된 데이터 멤버를 포함하는데, 이것은 새로운 임포트를 추가할 수 있는 파이"
"썬 ``set()``\\이다.  예를 들어, 만약 ``MySpecialType``\\이 ``mymodel."
"types``\\으로 불리는 모듈 안에 있고, ‘타입’을 만나면 임포트를 추가할 수 "
"있다::"

#: ../autogenerate.rst:372
msgid ""
"The ``autogen_context`` data member passed to the ``render_item`` "
"callable is now an instance of :class:`.AutogenContext`."
msgstr ""
"호출 가능한 ``render_item``\\에 전달된 ``autoget_context`` 데이터 멤버는 "
"이제 :class:`.AutogenContext`\\의 인스턴스이다."

#: ../autogenerate.rst:375
msgid ""
"The \"imports\" data member of the autogen context is restored to the "
"new :class:`.AutogenContext` object as :attr:`.AutogenContext.imports`."
msgstr ""
"이 autogen context의 “임포트” 데이터 멤버는 attr:`.AutogenContext."
"imports`\\라는 새로운 :class:`.AutogenContext` 객체로 복원된다."

#: ../autogenerate.rst:379
msgid ""
"The finished migration script will include our imports where the ``"
"${imports}`` expression is used, producing output such as::"
msgstr ""
"완료된 마이그레이션 스크립트는 ``${imports}`` 표현이 사용된 위치에 임포트"
"를 포함할 것이고, 다음과 같은 결과를 만든다::"

#: ../autogenerate.rst:393
msgid "Comparing Types"
msgstr "타입 비교"

#: ../autogenerate.rst:395
msgid ""
"The default type comparison logic will work for SQLAlchemy built in "
"types as well as basic user defined types.   This logic is only enabled "
"if the :paramref:`.EnvironmentContext.configure.compare_type` parameter "
"is set to True::"
msgstr ""
"기본 타입 비교 로직은 기본적인 사용자 정의 타입 뿐 아니라 타입으로 만들어"
"진 SQLAlchemy에도 적용될 것이다.  이 로직은 :paramref:`."
"EnvironmentContext.configure.compare_type`\\의 매개변수가 참일 때 활성화"
"된다::"

#: ../autogenerate.rst:405
msgid ""
"Alternatively, the :paramref:`.EnvironmentContext.configure."
"compare_type` parameter accepts a callable function which may be used to "
"implement custom type comparison logic, for cases such as where special "
"user defined types are being used::"
msgstr ""
"그렇지 않고 특별한 사용자 정의 타입을 사용하는 경우, :paramref:`."
"EnvironmentContext.configure.compare_type`\\의 매개변수로 사용자 정의 타"
"입 비교 로직으로 구현하기 위해 사용될 수 있는 호출 가능한 함수를 받는다::"

#: ../autogenerate.rst:423
msgid ""
"Above, ``inspected_column`` is a :class:`sqlalchemy.schema.Column` as "
"returned by :meth:`sqlalchemy.engine.reflection.Inspector.reflecttable`, "
"whereas ``metadata_column`` is a :class:`sqlalchemy.schema.Column` from "
"the local model environment.  A return value of ``None`` indicates that "
"default type comparison to proceed."
msgstr ""
"위에서, ``inspected_column``\\은 :meth:`sqlalchemy.engine.reflection."
"Inspector.reflecttable`\\이 반환하는 :class:`sqlalchemy.schema.Column`"
"\\이다. 반면 ``metadata_column``\\은 로컬 모델 환경의 :class:`sqlalchemy."
"schema.Column`\\이다.  ``None``으로 반환된 값은 기본 타입 비교가 진행되었"
"음을 나타낸다."

#: ../autogenerate.rst:430
msgid ""
"Additionally, custom types that are part of imported or third party "
"packages which have special behaviors such as per-dialect behavior "
"should implement a method called ``compare_against_backend()`` on their "
"SQLAlchemy type.   If this method is present, it will be called where it "
"can also return True or False to specify the types compare as equivalent "
"or not; if it returns None, default type comparison logic will proceed::"
msgstr ""
"추가적으로, per-dialect와 같이 특수한 동작을 포함하는 임포트되거나 3rd "
"party 패키지의 일부인 사용자 맞춤형 타입은 SQLAlchemy 타입에 대해 "
"``compare_against_backend()``\\라는 메소드를 구현해야 한다.  만약 이 메소"
"드가 존재한다면, True 또는 False를 반환 할 수 있는 곳에서 호출되어 타입"
"이 동등한지 아닌지를 비교하도록 명시한다; 만약 None을 반환하면, 기본 타"
"입 비교가 진행된 것이다::"

#: ../autogenerate.rst:455
msgid ""
"The boolean return values for the above ``compare_against_backend`` "
"method, which is part of SQLAlchemy and not Alembic,are **the opposite** "
"of that of the :paramref:`.EnvironmentContext.configure.compare_type` "
"callable, returning ``True`` for types that are the same vs. ``False`` "
"for types that are different.The :paramref:`.EnvironmentContext."
"configure.compare_type` callable on the other hand should return "
"``True`` for types that are **different**."
msgstr ""
"Alembic은 아니면서 SQLAlchemy의 일부분인 위쪽의 "
"``compare_against_backend`` 메소드에 대한 불리언 반환값은 호출 가능한 :"
"paramref:`.EnvironmentContext.configure.compare_type`\\와 **정반대**인"
"데, 동일한 타입일 때 ``True``\\을 반환하고 다른 타입이면 ``False``\\를 반"
"환한다. 반면에 호출 가능한 :paramref:`.EnvironmentContext.configure."
"compare_type`\\은 타입이 **다른** 경우에 ``True``를 반환해야 한다."

#: ../autogenerate.rst:464
msgid ""
"The order of precedence regarding the :paramref:`.EnvironmentContext."
"configure.compare_type` callable vs. the type itself implementing "
"``compare_against_backend`` is that the :paramref:`.EnvironmentContext."
"configure.compare_type` callable is favored first; if it returns "
"``None``, then the ``compare_against_backend`` method will be used, if "
"present on the metadata type.  If that returns ``None``, then a basic "
"check for type equivalence is run."
msgstr ""
":paramref:`.EnvironmentContext.configure.compare_type`\\와 "
"``compare_against_backend``\\를 구현하는 타입 자체 사이의 우선 순위는 :"
"paramref:`.EnvironmentContext.configure.compare_type`\\을 우선시 하는 것"
"이 선호된다; 만약 ``None``\\을 반환하면, 메타데이터 타입이 있을 경우, "
"`compare_against_backend`` 메소드가 사용된다.  만약 ``None``\\이 반환되"
"면, 타입 동등성에 대한 기본 검사가 실행된다."

#: ../autogenerate.rst:472
msgid "- added support for the ``compare_against_backend()`` method."
msgstr "- ``compare_against_backend()`` 메소드 지원이 추가됨."
